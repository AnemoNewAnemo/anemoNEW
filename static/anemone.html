<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <!-- Запрещаем зум самой страницы, чтобы работали жесты Three.js -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite Canvas</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; color: #000; font-family: sans-serif; touch-action: none; /* Важно для жестов */ }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #loading { 
            position: absolute; bottom: 20px; right: 20px; 
            font-size: 10px; color: #aaa; pointer-events: none; 
            opacity: 1; transition: opacity 0.5s; 
            background: rgba(255,255,255,0.8); padding: 5px;
            border-radius: 4px;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="loading">CONNECTING...</div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';

        // --- НАСТРОЙКИ ---
        const CHUNK_SIZE = 1500; 
        const RENDER_DISTANCE = 1; 
        const FADE_DISTANCE = 1200; 
        const MAX_CONCURRENT_LOADS = 6; // Чуть увеличили поток

        // --- ГЕНЕРАЦИЯ ТЕКСТУРЫ ЗАГРУЗКИ (Точки) ---
        function createPlaceholderTexture() {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Фон
            ctx.fillStyle = '#f0f0f0'; 
            ctx.fillRect(0, 0, size, size);

            // Рамка
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 10;
            ctx.strokeRect(0, 0, size, size);

            // Точки
            ctx.fillStyle = '#b0b0b0';
            ctx.font = 'bold 80px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('• • •', size/2, size/2);

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }
        
        const PLACEHOLDER_TEXTURE = createPlaceholderTexture();

        // --- СОСТОЯНИЕ ---
        const state = {
            chunks: new Map(),
            targetPos: new THREE.Vector3(0, 0, 1000), 
            currentPos: new THREE.Vector3(0, 0, 1000), 
            
            // Мышь
            isDragging: false,
            lastMouse: { x: 0, y: 0 },
            
            // Тач (2 пальца)
            lastTouchDist: 0,
            
            currentChunk: { x: null, y: null, z: null },
            loadQueue: [],
            activeLoads: 0
        };

        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); 
        scene.fog = new THREE.FogExp2(0xffffff, 0.00035); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 10, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        container.appendChild(renderer.domElement);

        const loader = new THREE.TextureLoader();
        loader.setCrossOrigin('anonymous');

        // --- МЕНЕДЖЕР ЗАГРУЗКИ ---
        function processLoadQueue() {
            if (state.activeLoads >= MAX_CONCURRENT_LOADS || state.loadQueue.length === 0) return;

            const task = state.loadQueue.shift(); // Берем FIFO, можно переделать на LIFO для актуальности
            state.activeLoads++;

            fetch(`/api/anemone/resolve_image?post_id=${task.postId}`)
                .then(r => r.json())
                .then(data => {
                    if (data.found && data.url) {
                        loader.load(data.url, (tex) => {
                            task.onSuccess(tex, data.ratio);
                            state.activeLoads--;
                            processLoadQueue();
                        }, undefined, () => {
                            task.onError();
                            state.activeLoads--;
                            processLoadQueue();
                        });
                    } else {
                        task.onError();
                        state.activeLoads--;
                        processLoadQueue();
                    }
                })
                .catch(() => {
                    task.onError();
                    state.activeLoads--;
                    processLoadQueue();
                });
        }

        function queueImageLoad(postId, onSuccess, onError) {
            // Добавляем в начало массива (LIFO), чтобы грузить то, что перед глазами сейчас
            // или в конец (FIFO). Для навигации лучше LIFO, но проще push.
            state.loadQueue.push({ postId, onSuccess, onError });
            processLoadQueue();
        }

        // --- СОЗДАНИЕ ОБЪЕКТОВ ---
        async function loadChunk(cx, cy, cz) {
            const key = `${cx},${cy},${cz}`;
            if (state.chunks.has(key)) return;

            const chunkGroup = new THREE.Group();
            chunkGroup.position.set(cx * CHUNK_SIZE, cy * CHUNK_SIZE, cz * CHUNK_SIZE);
            scene.add(chunkGroup);

            const chunkData = { group: chunkGroup, items: [] };
            state.chunks.set(key, chunkData);

            try {
                const res = await fetch(`/api/anemone/get_chunk?x=${cx}&y=${cy}&z=${cz}`);
                const data = await res.json();

                if (data.items) {
                    data.items.forEach(item => {
                        createArtObject(chunkGroup, item);
                    });
                }
            } catch (e) { console.error(e); }
        }

        function createArtObject(group, data) {
            const baseScale = data.scale[0];
            const geometry = new THREE.PlaneGeometry(1, 1);
            
            // СРАЗУ ставим заглушку и opacity 1, чтобы видеть блоки
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                map: PLACEHOLDER_TEXTURE, // Наши точки
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 1 
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(data.pos[0], data.pos[1], data.pos[2]);
            mesh.rotation.set(data.rotation[0], data.rotation[1], 0);
            
            // Квадратная форма пока грузится
            mesh.scale.set(baseScale, baseScale, 1);
            
            group.add(mesh);

            mesh.userData = { isLoaded: false };

            queueImageLoad(data.post_id, 
                (texture, ratio) => {
                    // Успех
                    texture.colorSpace = THREE.SRGBColorSpace;
                    texture.minFilter = THREE.LinearFilter;
                    
                    material.map = texture;
                    material.needsUpdate = true;
                    
                    // Адаптация пропорций
                    if (ratio >= 1) {
                         mesh.scale.set(baseScale, baseScale / ratio, 1);
                    } else {
                         mesh.scale.set(baseScale * ratio, baseScale, 1);
                    }

                    mesh.userData.isLoaded = true;
                },
                () => {
                    // Ошибка: делаем полупрозрачным красным или удаляем
                    // material.color.set(0xffcccc); 
                    // Или просто удаляем:
                    geometry.dispose();
                    material.dispose();
                    group.remove(mesh);
                }
            );
        }

        function unloadChunk(key) {
            const chunk = state.chunks.get(key);
            if (chunk) {
                scene.remove(chunk.group);
                chunk.group.traverse((obj) => {
                    if (obj.isMesh) {
                        obj.geometry.dispose();
                        if (obj.material.map && obj.material.map !== PLACEHOLDER_TEXTURE) {
                            obj.material.map.dispose();
                        }
                        obj.material.dispose();
                    }
                });
                state.chunks.delete(key);
            }
        }

        function updateChunks() {
            const cx = Math.floor(state.currentPos.x / CHUNK_SIZE + 0.5);
            const cy = Math.floor(state.currentPos.y / CHUNK_SIZE + 0.5);
            const cz = Math.floor(state.currentPos.z / CHUNK_SIZE + 0.5);

            if (cx !== state.currentChunk.x || cy !== state.currentChunk.y || cz !== state.currentChunk.z) {
                state.currentChunk = { x: cx, y: cy, z: cz };
                const activeKeys = new Set();
                
                for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                    for (let y = -RENDER_DISTANCE; y <= RENDER_DISTANCE; y++) {
                        for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                            loadChunk(cx + x, cy + y, cz + z);
                            activeKeys.add(`${cx+x},${cy+y},${cz+z}`);
                        }
                    }
                }
                for (const key of state.chunks.keys()) {
                    if (!activeKeys.has(key)) unloadChunk(key);
                }
            }
        }

        // --- УПРАВЛЕНИЕ (MOUSE) ---
        function onMove(dx, dy) {
             const speed = 2.5;
             state.targetPos.x -= dx * speed;
             // ИНВЕРСИЯ ВЕРТИКАЛЬНОЙ ОСИ: теперь -= вместо +=
             state.targetPos.y -= dy * speed; 
        }

        window.addEventListener('mousedown', e => { 
            state.isDragging = true; 
            state.lastMouse = { x: e.clientX, y: e.clientY }; 
        });
        window.addEventListener('mouseup', () => state.isDragging = false);
        window.addEventListener('mousemove', e => {
            if (!state.isDragging) return;
            onMove(e.clientX - state.lastMouse.x, e.clientY - state.lastMouse.y);
            state.lastMouse = { x: e.clientX, y: e.clientY };
        });
        
        // Колесико - зум
        window.addEventListener('wheel', e => { 
            state.targetPos.z += e.deltaY * 1.5; 
        }, { passive: true });


        // --- УПРАВЛЕНИЕ (TOUCH - 2 Fingers) ---
        function getDistance(t1, t2) {
            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            return Math.sqrt(dx*dx + dy*dy);
        }

        window.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                state.isDragging = true;
                state.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                state.isDragging = false; // Отключаем обычный драг
                state.lastTouchDist = getDistance(e.touches[0], e.touches[1]);
            }
        }, { passive: false });

        window.addEventListener('touchmove', e => {
             // Предотвращаем скролл страницы браузера
             e.preventDefault(); 

             if (e.touches.length === 1 && state.isDragging) {
                const dx = e.touches[0].clientX - state.lastMouse.x;
                const dy = e.touches[0].clientY - state.lastMouse.y;
                state.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                onMove(dx, dy);
             } 
             else if (e.touches.length === 2) {
                // Щипок (Pinch)
                const dist = getDistance(e.touches[0], e.touches[1]);
                const delta = dist - state.lastTouchDist;
                
                // Чувствительность зума
                state.targetPos.z -= delta * 3.0; 
                state.lastTouchDist = dist;
             }
        }, { passive: false });

        window.addEventListener('touchend', () => {
            state.isDragging = false;
        });

        // --- RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            state.currentPos.lerp(state.targetPos, 0.08); // Чуть плавнее
            camera.position.copy(state.currentPos);

            updateChunks();

            // Эффект тумана и видимости
            state.chunks.forEach(chunk => {
                chunk.group.children.forEach(mesh => {
                    const dist = mesh.position.clone().add(chunk.group.position).distanceTo(camera.position);

                    // Если загружено - полная видимость с учетом тумана
                    // Если не загружено (точки) - тоже видимость
                    
                    let opacity = 1;
                    if (dist > FADE_DISTANCE) {
                         opacity = 1 - Math.min((dist - FADE_DISTANCE) / 500, 1);
                    }
                    
                    mesh.material.opacity = opacity;
                    mesh.visible = opacity > 0.05;
                });
            });

            renderer.render(scene, camera);
        }

        animate();
        
        setTimeout(() => document.getElementById('loading').style.opacity = 0, 500);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
