<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Anemone Infinite Arts</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: #fff; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; transition: opacity 0.5s; }
        .ui-overlay { position: absolute; bottom: 20px; left: 20px; pointer-events: none; opacity: 0.7; }
        .hint { font-size: 12px; color: #888; }
    </style>
    <!-- Подключаем Three.js через CDN -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="loading">Загрузка бесконечности...</div>
    <div id="canvas-container"></div>
    <div class="ui-overlay">
        <div>Anemone Arts Gallery</div>
        <div class="hint">Drag to move • Scroll to zoom (Z)</div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- КОНФИГУРАЦИЯ ---
        const CHUNK_SIZE = 2000; // Размер одного "куба" пространства
        const RENDER_DISTANCE = 1; // Сколько чанков грузить вокруг (1 = сетка 3x3x3)
        const FADE_DISTANCE = 1500; // Расстояние, на котором картины исчезают
        
        // --- СОСТОЯНИЕ ---
        const state = {
            chunks: new Map(), // Хранилище загруженных чанков: key "x,y,z" -> object
            targetPos: new THREE.Vector3(0, 0, 1000), // Куда стремится камера
            currentPos: new THREE.Vector3(0, 0, 1000), // Где камера сейчас (для инерции)
            velocity: new THREE.Vector3(0, 0, 0),
            isDragging: false,
            lastMouse: { x: 0, y: 0 },
            currentChunk: { x: null, y: null, z: null }
        };

        // --- ИНИЦИАЛИЗАЦИЯ THREE.JS ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.00035); // Туман для скрытия границ

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 10, 8000);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Текстура-заглушка
        const loader = new THREE.TextureLoader();
        const placeholderTex = loader.load('https://via.placeholder.com/10x10/333/333');

        // --- ЛОГИКА ЧАНКОВ (The Core) ---

        function getChunkKey(x, y, z) {
            return `${x},${y},${z}`;
        }

        async function loadChunk(cx, cy, cz) {
            const key = getChunkKey(cx, cy, cz);
            if (state.chunks.has(key)) return; // Уже загружен

            // Создаем группу для чанка
            const chunkGroup = new THREE.Group();
            chunkGroup.position.set(cx * CHUNK_SIZE, cy * CHUNK_SIZE, cz * CHUNK_SIZE);
            scene.add(chunkGroup);

            // Помечаем как "загружается"
            const chunkData = { group: chunkGroup, items: [], loaded: false };
            state.chunks.set(key, chunkData);

            try {
                // Запрос к API Flask
                const res = await fetch(`/api/anemone/get_chunk?x=${cx}&y=${cy}&z=${cz}`);
                const data = await res.json();

                if (data.items) {
                    data.items.forEach(item => {
                        createArtObject(chunkGroup, item);
                    });
                }
                chunkData.loaded = true;
            } catch (e) {
                console.error("Ошибка загрузки чанка", e);
            }
        }

        function createArtObject(group, data) {
            // Геометрия
            // Геометрия
            const geometry = new THREE.PlaneGeometry(data.scale[0], data.scale[1]);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0 
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            mesh.position.set(data.pos[0], data.pos[1], data.pos[2]);
            mesh.rotation.set(data.rotation[0], data.rotation[1], data.rotation[2]);
            
            group.add(mesh);

            // Ленивая загрузка
            fetch(`/api/anemone/resolve_image?post_id=${data.post_id}`)
                .then(r => r.json())
                .then(json => {
                    if(json.url) {
                        loader.setCrossOrigin('anonymous'); // Обязательно для текстур из веба
                        
                        // Используем loadAsync или обычный load, но с проверкой
                        loader.load(json.url, (tex) => {
                            tex.colorSpace = THREE.SRGBColorSpace;
                            
                            // Проверка соотношения сторон (опционально, чтобы не растягивало)
                            const aspect = tex.image.width / tex.image.height;
                            // Можно скорректировать mesh.scale.x = mesh.scale.y * aspect;
            
                            material.map = tex;
                            material.color.setHex(0xffffff); // Возвращаем белый цвет (чтобы текстура была видна)
                            material.opacity = 1; // Делаем видимым
                            material.needsUpdate = true;
                        }, 
                        undefined, // onProgress
                        (err) => {
                            // Если картинка не загрузилась (битая ссылка)
                            console.warn("Texture load fail", err);
                            material.color.setHex(0x222222); // Темно-серый квадрат
                            material.opacity = 0.5;
                        });
                    } else {
                        // Если сервер вернул заглушку или null
                        material.color.setHex(0x111111);
                    }
                })
                .catch(err => {
                    // Ошибка сети
                    console.error(err);
                });

            const worldPos = new THREE.Vector3();
            mesh.getWorldPosition(worldPos);
            mesh.userData = { worldPos: worldPos, opacity: 0 };
        }

        function unloadChunk(key) {
            const chunk = state.chunks.get(key);
            if (chunk) {
                scene.remove(chunk.group);
                // Очистка памяти (важно для бесконечности)
                chunk.group.children.forEach(mesh => {
                    if (mesh.geometry) mesh.geometry.dispose();
                    if (mesh.material) {
                        if (mesh.material.map) mesh.material.map.dispose();
                        mesh.material.dispose();
                    }
                });
                state.chunks.delete(key);
            }
        }

        function updateChunks() {
            // 1. Вычисляем текущий чанк
            const cx = Math.floor(state.currentPos.x / CHUNK_SIZE + 0.5);
            const cy = Math.floor(state.currentPos.y / CHUNK_SIZE + 0.5);
            const cz = Math.floor(state.currentPos.z / CHUNK_SIZE + 0.5);

            // Если чанк сменился, запускаем пересчет
            if (cx !== state.currentChunk.x || cy !== state.currentChunk.y || cz !== state.currentChunk.z) {
                state.currentChunk = { x: cx, y: cy, z: cz };
                
                // Определяем какие чанки должны быть
                const activeKeys = new Set();
                
                for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                    for (let y = -RENDER_DISTANCE; y <= RENDER_DISTANCE; y++) {
                        for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                            const key = getChunkKey(cx + x, cy + y, cz + z);
                            activeKeys.add(key);
                            loadChunk(cx + x, cy + y, cz + z);
                        }
                    }
                }

                // Удаляем старые
                for (const key of state.chunks.keys()) {
                    if (!activeKeys.has(key)) {
                        unloadChunk(key);
                    }
                }
            }
        }

        // --- УПРАВЛЕНИЕ (Мышь + Тач) ---
        
        // Desktop
        window.addEventListener('mousedown', e => {
            state.isDragging = true;
            state.lastMouse = { x: e.clientX, y: e.clientY };
        });
        window.addEventListener('mouseup', () => state.isDragging = false);
        window.addEventListener('mousemove', e => {
            if (!state.isDragging) return;
            const dx = e.clientX - state.lastMouse.x;
            const dy = e.clientY - state.lastMouse.y;
            state.lastMouse = { x: e.clientX, y: e.clientY };

            // Двигаем ЦЕЛЬ (target), а не саму камеру (для плавности)
            state.targetPos.x -= dx * 2.5;
            state.targetPos.y += dy * 2.5;
        });
        window.addEventListener('wheel', e => {
            // Колесико двигает по Z (Zoom)
            state.targetPos.z += e.deltaY * 2.5;
        }, { passive: true });

        // Mobile (Touch)
        window.addEventListener('touchstart', e => {
            if(e.touches.length === 1) {
                state.isDragging = true;
                state.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }, { passive: false });
        
        window.addEventListener('touchmove', e => {
            if (e.touches.length === 1 && state.isDragging) {
                const dx = e.touches[0].clientX - state.lastMouse.x;
                const dy = e.touches[0].clientY - state.lastMouse.y;
                state.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                
                state.targetPos.x -= dx * 4; // Чуть быстрее на таче
                state.targetPos.y += dy * 4;
            }
            // Простой зум двумя пальцами можно добавить через e.touches.length === 2
        }, { passive: false });
        
        window.addEventListener('touchend', () => state.isDragging = false);


        // --- MAIN LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            // 1. Физика камеры (Инерция)
            // Плавная интерполяция от текущей позиции к целевой (Lerp)
            state.currentPos.lerp(state.targetPos, 0.08);
            camera.position.copy(state.currentPos);

            // 2. Обновление мира
            updateChunks();

            // 3. Эффекты (Fading объектов)
            state.chunks.forEach(chunk => {
                if (!chunk.group) return;
                chunk.group.children.forEach(mesh => {
                    if (!mesh.userData.worldPos) return;

                    // Обновляем мировую позицию для расчета дистанции
                    // (так как чанк на месте, но камера двигается)
                    // Упрощение: считаем distance от камеры до центра объекта
                    // Для правильного расчета нам нужны абсолютные координаты mesh
                    // Мы их знаем: chunkPos + localPos.
                    
                    // Расстояние до камеры
                    const dist = mesh.position.clone().add(chunk.group.position).distanceTo(camera.position);

                    // Логика прозрачности
                    let targetOpacity = 1;
                    if (dist > FADE_DISTANCE) {
                        targetOpacity = 0;
                    } else if (dist > FADE_DISTANCE - 500) {
                        targetOpacity = 1 - (dist - (FADE_DISTANCE - 500)) / 500;
                    }

                    // Плавное изменение прозрачности
                    mesh.material.opacity += (targetOpacity - mesh.material.opacity) * 0.1;
                    
                    // Оптимизация: скрываем совсем невидимые
                    mesh.visible = mesh.material.opacity > 0.01;
                });
            });

            renderer.render(scene, camera);
        }

        // Запуск
        animate();
        document.getElementById('loading').style.opacity = 0;

        // Ресайз окна
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Telegram WebApp Setup
        if (window.Telegram?.WebApp) {
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.expand();
            window.Telegram.WebApp.enableClosingConfirmation();
        }
    </script>
</body>
</html>

