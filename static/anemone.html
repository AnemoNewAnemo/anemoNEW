<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Infinite Hanging Gallery</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; color: #000; font-family: 'Helvetica Neue', sans-serif; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* Упрощенный индикатор подключения */
        #status { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            font-size: 11px; color: #aaa; letter-spacing: 2px; pointer-events: none; 
            opacity: 1; transition: opacity 0.8s; text-transform: uppercase;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="status">Connecting...</div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';

        // --- НАСТРОЙКИ ---
        const CHUNK_SIZE = 1500; 
        const RENDER_DISTANCE = 1; 
        const FADE_DISTANCE = 1400; 
        const MAX_CONCURRENT_LOADS = 6;

        // --- ГЕНЕРАЦИЯ ТЕКСТУРЫ ЗАГРУЗКИ (Минимализм) ---
        function createPlaceholderTexture() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            // 1. Светлый фон
            ctx.fillStyle = '#fafafa'; 
            ctx.fillRect(0, 0, size, size);

            // 2. Очень тонкая рамка
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 2; // Тонкая линия
            ctx.strokeRect(0, 0, size, size);

            // 3. Текст LOADING красивым шрифтом
            ctx.fillStyle = '#888888';
            ctx.font = '300 24px "Helvetica Neue", Arial, sans-serif'; // Тонкий шрифт
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('L O A D I N G', size/2, size/2 + 40); // Чуть ниже центра

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }
        
        const PLACEHOLDER_TEXTURE = createPlaceholderTexture();
        
        // Материал для "точки" загрузки
        const DOT_TEXTURE = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/disc.png'); 

        // --- СОСТОЯНИЕ ---
        const state = {
            chunks: new Map(),
            targetPos: new THREE.Vector3(0, 0, 1000), 
            currentPos: new THREE.Vector3(0, 0, 1000), 
            isDragging: false,
            lastMouse: { x: 0, y: 0 },
            lastTouchDist: 0,
            currentChunk: { x: null, y: null, z: null },
            loadQueue: [],
            activeLoads: 0
        };

        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); 
        scene.fog = new THREE.FogExp2(0xffffff, 0.0003); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 10, 8000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        container.appendChild(renderer.domElement);

        const textureLoader = new THREE.TextureLoader();
        textureLoader.setCrossOrigin('anonymous');

        // --- ОЧЕРЕДЬ ЗАГРУЗКИ ---
        function processLoadQueue() {
            if (state.activeLoads >= MAX_CONCURRENT_LOADS || state.loadQueue.length === 0) return;
            const task = state.loadQueue.shift();
            state.activeLoads++;

            fetch(`/api/anemone/resolve_image?post_id=${task.postId}`)
                .then(r => r.json())
                .then(data => {
                    if (data.found && data.url) {
                        textureLoader.load(data.url, (tex) => {
                            task.onSuccess(tex, data.ratio);
                            state.activeLoads--;
                            processLoadQueue();
                        }, undefined, () => {
                            task.onError();
                            state.activeLoads--;
                            processLoadQueue();
                        });
                    } else {
                        task.onError();
                        state.activeLoads--;
                        processLoadQueue();
                    }
                })
                .catch(() => {
                    task.onError();
                    state.activeLoads--;
                    processLoadQueue();
                });
        }

        function queueImageLoad(postId, onSuccess, onError) {
            state.loadQueue.push({ postId, onSuccess, onError });
            processLoadQueue();
        }

        // --- СОЗДАНИЕ ОБЪЕКТОВ ---
        async function loadChunk(cx, cy, cz) {
            const key = `${cx},${cy},${cz}`;
            if (state.chunks.has(key)) return;

            const chunkGroup = new THREE.Group();
            chunkGroup.position.set(cx * CHUNK_SIZE, cy * CHUNK_SIZE, cz * CHUNK_SIZE);
            scene.add(chunkGroup);
            state.chunks.set(key, { group: chunkGroup });

            try {
                const res = await fetch(`/api/anemone/get_chunk?x=${cx}&y=${cy}&z=${cz}`);
                const data = await res.json();
                if (data.items) {
                    data.items.forEach(item => createHangingArt(chunkGroup, item));
                }
            } catch (e) { console.error(e); }
        }

        function createHangingArt(group, data) {
            const baseScale = data.scale[0];
            
            // 1. ГЕОМЕТРИЯ КАРТИНЫ
            // Смещаем геометрию вниз на 0.5, чтобы origin (0,0,0) был посередине ВЕРХНЕЙ грани.
            // Это нужно для правильного вращения (эффект маятника).
            const geometry = new THREE.PlaneGeometry(1, 1);
            geometry.translate(0, -0.5, 0); 

            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                map: PLACEHOLDER_TEXTURE,
                side: THREE.DoubleSide,
                transparent: true 
            });

            const mesh = new THREE.Mesh(geometry, material);
            
            // Компенсируем смещение геометрии в позиции объекта, чтобы сетка осталась ровной
            // data.pos[1] - это центр. Мы хотим, чтобы верх был выше центра на пол-высоты.
            // Но так как pivot теперь наверху, ставим объект в точку, где должен быть верхний край.
            mesh.position.set(data.pos[0], data.pos[1] + (baseScale / 2), data.pos[2]);
            
            mesh.scale.set(baseScale, baseScale, 1);

            // Случайные параметры для анимации (фаза и скорость покачивания)
            mesh.userData = { 
                isLoaded: false,
                randomPhase: Math.random() * Math.PI * 2,
                swaySpeed: 0.5 + Math.random() * 0.5,
                tiltSpeed: 0.3 + Math.random() * 0.4
            };
            
            // 2. ВЕРЕВОЧКА (ЛИНИЯ ВВЕРХ)
            // Линия идет из локального (0,0,0) - это верх картинки, вертикально вверх
            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 5000, 0) // Очень длинная линия вверх
            ]);
            const lineMat = new THREE.LineBasicMaterial({ 
                color: 0x000000, 
                transparent: true, 
                opacity: 0.15, // Еле заметная
                linewidth: 1 
            });
            const line = new THREE.Line(lineGeo, lineMat);
            mesh.add(line); // Линия привязана к мешу, она будет качаться вместе с ним

            // 3. ПУЛЬСИРУЮЩАЯ ТОЧКА (Loading Dot)
            // Создаем маленький круг
            const dotGeo = new THREE.CircleGeometry(0.03, 16); // Маленький размер относительно 1.0
            const dotMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3 });
            const dotMesh = new THREE.Mesh(dotGeo, dotMat);
            // Позиция точки: т.к. геометрия сдвинута на -0.5 по Y, центр картины теперь в -0.5
            dotMesh.position.set(0, -0.5, 0.01); 
            mesh.add(dotMesh);
            mesh.userData.loadingDot = dotMesh; // Ссылка для анимации

            group.add(mesh);

            // 4. ЗАГРУЗКА ИЗОБРАЖЕНИЯ
            queueImageLoad(data.post_id, 
                (texture, ratio) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    texture.minFilter = THREE.LinearFilter;
                    
                    material.map = texture;
                    material.needsUpdate = true;
                    
                    // Удаляем точку загрузки
                    mesh.remove(dotMesh);
                    dotGeo.dispose();
                    dotMat.dispose();

                    // Адаптация размера с учетом того, что pivot сверху
                    if (ratio >= 1) {
                        // Широкая: ширина base, высота меньше
                        mesh.scale.set(baseScale, baseScale / ratio, 1);
                    } else {
                        // Высокая: ширина меньше, высота base
                        mesh.scale.set(baseScale * ratio, baseScale, 1);
                    }
                    mesh.userData.isLoaded = true;
                },
                () => {
                    // Ошибка: просто удаляем
                    group.remove(mesh);
                    geometry.dispose();
                    material.dispose();
                }
            );
        }

        function unloadChunk(key) {
            const chunk = state.chunks.get(key);
            if (chunk) {
                scene.remove(chunk.group);
                // Очистка памяти (упрощенно)
                chunk.group.traverse(o => {
                    if (o.geometry) o.geometry.dispose();
                    if (o.material) o.material.dispose();
                });
                state.chunks.delete(key);
            }
        }

        function updateChunks() {
            const cx = Math.floor(state.currentPos.x / CHUNK_SIZE + 0.5);
            const cy = Math.floor(state.currentPos.y / CHUNK_SIZE + 0.5);
            const cz = Math.floor(state.currentPos.z / CHUNK_SIZE + 0.5);

            if (cx !== state.currentChunk.x || cy !== state.currentChunk.y || cz !== state.currentChunk.z) {
                state.currentChunk = { x: cx, y: cy, z: cz };
                const activeKeys = new Set();
                
                for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                    for (let y = -RENDER_DISTANCE; y <= RENDER_DISTANCE; y++) {
                        for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                            loadChunk(cx + x, cy + y, cz + z);
                            activeKeys.add(`${cx+x},${cy+y},${cz+z}`);
                        }
                    }
                }
                for (const key of state.chunks.keys()) {
                    if (!activeKeys.has(key)) unloadChunk(key);
                }
            }
        }

        // --- УПРАВЛЕНИЕ ---
        function onMove(dx, dy) {
            const speed = 2.5;
            state.targetPos.x -= dx * speed;
            // !!! ИНВЕРСИЯ ЗДЕСЬ !!!
            // Чтобы картинки двигались вниз при движении пальца вниз,
            // камера должна двигаться ВВЕРХ (плюс по Y).
            state.targetPos.y += dy * speed; 
        }

        // MOUSE
        window.addEventListener('mousedown', e => { 
            state.isDragging = true; 
            state.lastMouse = { x: e.clientX, y: e.clientY }; 
            document.body.style.cursor = 'grabbing';
        });
        window.addEventListener('mouseup', () => {
            state.isDragging = false;
            document.body.style.cursor = 'default';
        });
        window.addEventListener('mousemove', e => {
            if (!state.isDragging) return;
            onMove(e.clientX - state.lastMouse.x, e.clientY - state.lastMouse.y);
            state.lastMouse = { x: e.clientX, y: e.clientY };
        });
        window.addEventListener('wheel', e => { 
            state.targetPos.z += e.deltaY * 1.5; 
        }, { passive: true });

        // TOUCH
        function getDistance(t1, t2) {
            return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
        }

        window.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                state.isDragging = true;
                state.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                state.isDragging = false;
                state.lastTouchDist = getDistance(e.touches[0], e.touches[1]);
            }
        }, { passive: false });

        window.addEventListener('touchmove', e => {
             e.preventDefault(); 
             if (e.touches.length === 1 && state.isDragging) {
                const dx = e.touches[0].clientX - state.lastMouse.x;
                const dy = e.touches[0].clientY - state.lastMouse.y;
                state.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                onMove(dx, dy);
             } 
             else if (e.touches.length === 2) {
                const dist = getDistance(e.touches[0], e.touches[1]);
                const delta = dist - state.lastTouchDist;
                state.targetPos.z -= delta * 3.0; 
                state.lastTouchDist = dist;
             }
        }, { passive: false });
        window.addEventListener('touchend', () => state.isDragging = false);

        // --- RENDER & ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Плавное движение камеры
            state.currentPos.lerp(state.targetPos, 0.08); 
            camera.position.copy(state.currentPos);

            updateChunks();

            const time = Date.now() * 0.001; // Время в секундах

            state.chunks.forEach(chunk => {
                chunk.group.children.forEach(mesh => {
                    // 1. Анимация покачивания (Swaying)
                    // Используем случайную фазу (userData.randomPhase), чтобы все качались по-разному
                    const phase = mesh.userData.randomPhase;
                    
                    // Основное качание влево-вправо (Z axis)
                    const swayZ = Math.sin(time * mesh.userData.swaySpeed + phase) * 0.08; 
                    
                    // Легкий наклон вперед-назад (X axis) и поворот (Y axis) - имитация воздушных потоков
                    const swayX = Math.sin(time * mesh.userData.tiltSpeed * 0.7 + phase) * 0.03;
                    const swayY = Math.cos(time * 0.2 + phase) * 0.05;

                    mesh.rotation.set(swayX, swayY, swayZ);

                    // 2. Анимация точки загрузки
                    if (!mesh.userData.isLoaded && mesh.userData.loadingDot) {
                        const dot = mesh.userData.loadingDot;
                        // Пульсация масштаба
                        const scale = 1 + Math.sin(time * 5) * 0.3;
                        dot.scale.set(scale, scale, 1);
                        // Пульсация прозрачности
                        dot.material.opacity = 0.3 + Math.sin(time * 5) * 0.2;
                    }

                    // 3. Туман (Fade distance)
                    const dist = mesh.position.clone().add(chunk.group.position).distanceTo(camera.position);
                    let opacity = 1;
                    if (dist > FADE_DISTANCE) {
                         opacity = 1 - Math.min((dist - FADE_DISTANCE) / 600, 1);
                    }
                    mesh.material.opacity = opacity;
                    // Линии делаем еще прозрачнее
                    if(mesh.children.length > 0 && mesh.children[0].isLine) {
                         mesh.children[0].material.opacity = opacity * 0.15;
                    }
                    mesh.visible = opacity > 0.05;
                });
            });

            renderer.render(scene, camera);
        }

        animate();
        
        // Скрыть надпись "Connecting" при старте
        setTimeout(() => document.getElementById('status').style.opacity = 0, 1000);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
