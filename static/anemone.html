<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Infinite Canvas</title>
    <style>
        /* 1) БЕЛЫЙ ФОН */
        body { margin: 0; overflow: hidden; background-color: #ffffff; color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* Лоадер минималистичный */
        #loading { 
            position: absolute; bottom: 20px; right: 20px; 
            font-size: 10px; color: #ccc; pointer-events: none; 
            opacity: 1; transition: opacity 0.5s; 
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <div id="loading">LOADING CANVAS...</div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';

        // --- НАСТРОЙКИ ---
        const CHUNK_SIZE = 1500; 
        const RENDER_DISTANCE = 1; 
        const FADE_DISTANCE = 1200; 
        
        // Лимит одновременных загрузок картинок (ускоряет работу, не забивая канал)
        const MAX_CONCURRENT_LOADS = 4;

        // --- СОСТОЯНИЕ ---
        const state = {
            chunks: new Map(),
            targetPos: new THREE.Vector3(0, 0, 1000), 
            currentPos: new THREE.Vector3(0, 0, 1000), 
            isDragging: false,
            lastMouse: { x: 0, y: 0 },
            currentChunk: { x: null, y: null, z: null },
            loadQueue: [], // Очередь на загрузку картинок
            activeLoads: 0 // Текущее кол-во загрузок
        };

        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        
        // 2) Белый фон и белый туман
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff); 
        scene.fog = new THREE.FogExp2(0xffffff, 0.0004); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 10, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Оптимизация DPI
        container.appendChild(renderer.domElement);

        const loader = new THREE.TextureLoader();
        loader.setCrossOrigin('anonymous');

        // --- МЕНЕДЖЕР ЗАГРУЗКИ (Очередь) ---
        function processLoadQueue() {
            if (state.activeLoads >= MAX_CONCURRENT_LOADS || state.loadQueue.length === 0) return;

            const task = state.loadQueue.shift();
            state.activeLoads++;

            fetch(`/api/anemone/resolve_image?post_id=${task.postId}`)
                .then(r => r.json())
                .then(data => {
                    if (data.found && data.url) {
                        loader.load(data.url, (tex) => {
                            task.onSuccess(tex, data.ratio);
                            state.activeLoads--;
                            processLoadQueue();
                        }, undefined, () => {
                            // Ошибка загрузки самой картинки
                            task.onError();
                            state.activeLoads--;
                            processLoadQueue();
                        });
                    } else {
                        // Картинки нет (текст или удалено)
                        task.onError();
                        state.activeLoads--;
                        processLoadQueue();
                    }
                })
                .catch(() => {
                    task.onError();
                    state.activeLoads--;
                    processLoadQueue();
                });
        }

        function queueImageLoad(postId, onSuccess, onError) {
            state.loadQueue.push({ postId, onSuccess, onError });
            processLoadQueue();
        }

        // --- ЛОГИКА ---

        async function loadChunk(cx, cy, cz) {
            const key = `${cx},${cy},${cz}`;
            if (state.chunks.has(key)) return;

            const chunkGroup = new THREE.Group();
            chunkGroup.position.set(cx * CHUNK_SIZE, cy * CHUNK_SIZE, cz * CHUNK_SIZE);
            scene.add(chunkGroup);

            const chunkData = { group: chunkGroup, items: [] };
            state.chunks.set(key, chunkData);

            try {
                const res = await fetch(`/api/anemone/get_chunk?x=${cx}&y=${cy}&z=${cz}`);
                const data = await res.json();

                if (data.items) {
                    data.items.forEach(item => {
                        createArtObject(chunkGroup, item);
                    });
                }
            } catch (e) {
                console.error("Chunk load error", e);
            }
        }

        function createArtObject(group, data) {
            // Создаем геометрию по умолчанию (1x1)
            const baseScale = data.scale[0]; // Берем базовый размер
            const geometry = new THREE.PlaneGeometry(1, 1);
            
            // Важно: Opacity 0. Объект невидим, пока не загрузится картинка.
            // Никаких белых квадратов.
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0 
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            // Позиция
            mesh.position.set(data.pos[0], data.pos[1], data.pos[2]);
            mesh.rotation.set(data.rotation[0], data.rotation[1], 0); // Z вращение убираем для строгости или оставляем по вкусу
            
            // Устанавливаем масштаб по умолчанию пока грузится
            mesh.scale.set(baseScale, baseScale, 1);
            
            group.add(mesh);

            // Добавляем в очередь на "проявку"
            queueImageLoad(data.post_id, 
                (texture, ratio) => {
                    // УСПЕХ:
                    texture.colorSpace = THREE.SRGBColorSpace;
                    texture.minFilter = THREE.LinearFilter;
                    
                    material.map = texture;
                    
                    // 3) ПРАВИЛЬНЫЕ ПРОПОРЦИИ
                    // Если ratio > 1 (альбомная): Ширина = Base, Высота = Base / Ratio
                    // Если ratio < 1 (портретная): Ширина = Base * Ratio, Высота = Base
                    // Но проще зафиксировать одну сторону, например ширину:
                    
                    // Вариант А: Фиксируем ширину (картинки разной высоты)
                    // mesh.scale.set(baseScale, baseScale / ratio, 1);

                    // Вариант Б: Вписываем в квадрат (fit)
                    if (ratio >= 1) {
                         mesh.scale.set(baseScale, baseScale / ratio, 1);
                    } else {
                         mesh.scale.set(baseScale * ratio, baseScale, 1);
                    }

                    material.needsUpdate = true;
                    
                    // Анимация появления (userData флаг)
                    mesh.userData.ready = true;
                },
                () => {
                    // ОШИБКА (или нет картинки):
                    // Удаляем меш, чтобы не висел призрак
                    geometry.dispose();
                    material.dispose();
                    group.remove(mesh);
                }
            );

            // Сохраняем позицию для расчета дистанции
            const worldPos = new THREE.Vector3();
            // Примерная позиция, точная будет при рендере
            mesh.userData = { opacity: 0, ready: false };
        }

        function unloadChunk(key) {
            const chunk = state.chunks.get(key);
            if (chunk) {
                scene.remove(chunk.group);
                chunk.group.traverse((obj) => {
                    if (obj.isMesh) {
                        obj.geometry.dispose();
                        if (obj.material.map) obj.material.map.dispose();
                        obj.material.dispose();
                    }
                });
                state.chunks.delete(key);
            }
        }

        function updateChunks() {
            const cx = Math.floor(state.currentPos.x / CHUNK_SIZE + 0.5);
            const cy = Math.floor(state.currentPos.y / CHUNK_SIZE + 0.5);
            const cz = Math.floor(state.currentPos.z / CHUNK_SIZE + 0.5);

            if (cx !== state.currentChunk.x || cy !== state.currentChunk.y || cz !== state.currentChunk.z) {
                state.currentChunk = { x: cx, y: cy, z: cz };
                const activeKeys = new Set();
                
                for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                    for (let y = -RENDER_DISTANCE; y <= RENDER_DISTANCE; y++) {
                        for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                            const key = `${cx + x},${cy + y},${cz + z}`;
                            activeKeys.add(key);
                            loadChunk(cx + x, cy + y, cz + z);
                        }
                    }
                }
                for (const key of state.chunks.keys()) {
                    if (!activeKeys.has(key)) unloadChunk(key);
                }
            }
        }

        // --- УПРАВЛЕНИЕ ---
        function onMove(dx, dy) {
             const speed = 2.5;
             state.targetPos.x -= dx * speed;
             state.targetPos.y += dy * speed;
        }
        
        window.addEventListener('mousedown', e => { state.isDragging = true; state.lastMouse = { x: e.clientX, y: e.clientY }; });
        window.addEventListener('mouseup', () => state.isDragging = false);
        window.addEventListener('mousemove', e => {
            if (!state.isDragging) return;
            onMove(e.clientX - state.lastMouse.x, state.lastMouse.y - e.clientY); // Y инвертирован в 2D->3D
            state.lastMouse = { x: e.clientX, y: e.clientY };
        });
        window.addEventListener('wheel', e => { state.targetPos.z += e.deltaY * 1.5; }, { passive: true });
        
        // Touch
        window.addEventListener('touchstart', e => {
            if(e.touches.length === 1) { state.isDragging = true; state.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY }; }
        }, { passive: false });
        window.addEventListener('touchmove', e => {
             if (e.touches.length === 1 && state.isDragging) {
                const dx = e.touches[0].clientX - state.lastMouse.x;
                const dy = e.touches[0].clientY - state.lastMouse.y; // Внимание на знак
                state.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                onMove(dx, -dy);
             }
        }, { passive: false });
        window.addEventListener('touchend', () => state.isDragging = false);

        // --- RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Инерция камеры
            state.currentPos.lerp(state.targetPos, 0.05);
            camera.position.copy(state.currentPos);

            updateChunks();

            // Эффекты
            state.chunks.forEach(chunk => {
                chunk.group.children.forEach(mesh => {
                    // Расчет дистанции
                    const dist = mesh.position.clone().add(chunk.group.position).distanceTo(camera.position);

                    let targetOpacity = 0;
                    
                    // Показываем только если загрузилось (userData.ready)
                    if (mesh.userData.ready) {
                         if (dist < FADE_DISTANCE) {
                            // Плавное затухание на границе
                            targetOpacity = 1 - Math.pow(dist / FADE_DISTANCE, 2); 
                         }
                    }

                    // Плавная анимация прозрачности (Crossfade)
                    mesh.material.opacity += (targetOpacity - mesh.material.opacity) * 0.05;
                    mesh.visible = mesh.material.opacity > 0.01;
                });
            });

            renderer.render(scene, camera);
        }

        animate();
        
        // Скрываем надпись загрузки
        setTimeout(() => document.getElementById('loading').style.opacity = 0, 1000);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
